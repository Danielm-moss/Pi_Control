# Compile the C++ trigger program
echo "Compiling trigger program..."
echo "Source file trig.cpp last modified: $(stat -c %y trig.cpp)"
g++ -o trig trig.cpp -lgpiodcxx -std=c++17
echo "Compiled binary trig last modified: $(stat -c %y trig)"

# Start the capture script
echo "Starting capture script..."
echo "Script cap.sh last modified: $(stat -c %y cap.sh)"
./cap.sh & 
CAPTURE_PID=$!

# Give the capture script a moment to initialize
sleep 1

# Start the trigger program
echo "Starting trigger program..."
sudo ./trig

# Wait for capture script to finish
wait $CAPTURE_PID

echo "All processes completed."





# Setup output directory for captured frames
OUTDIR="$HOME/Projects/moss/frames"
mkdir -p "$OUTDIR"

echo 1 | sudo tee /sys/module/imx296/parameters/trigger_mode >/dev/null # Make sure camera is external tirgger mode

EXPOSURES=(50000) # Exposure times in microseconds
GAIN=1
TIMESTAMP=$(date +%Y%m%d_%H%M%S) # Unique timestamp for this run

time_array_size=${#EXPOSURES[@]}
trigger_count=0 # Total number of captures taken
current_time=0 # Index into EXPOSURES array

# Capture loop: cycles through exposure times, taking F and B captures for each
while [ "$current_time" -lt "$time_array_size" ]; do
    exp_us=${EXPOSURES[$current_time]}

    # Alternate between Forward (F) and Backward (B) passes
    if [ $((trigger_count % 2)) -eq 0 ]; then
        DIR="F"  
    else
        DIR="B"
    fi

    filename="$OUTDIR/T:${exp_us}_G:${GAIN}_${DIR}.jpg" # File name with timestamp

    echo "Waiting for trigger $((trigger_count + 1))..."
    # the one shutter time is just a place holder
    rpicam-still -n --shutter 1 --gain "$GAIN" -o "$filename"
    echo "Captured frame: $filename"

    trigger_count=$((trigger_count + 1))

    # After both F and B captures (every 2nd trigger), move to next exposure time
    if [ $((trigger_count % 2)) -eq 0 ]; then
        current_time=$((current_time + 1))
    fi
done

echo "Capture sequence completed: $trigger_count frames captured."

# chmod +x cap.sh
# ./cap.sh





#include <iostream>
#include <gpiod.hpp>
#include <thread>
#include <chrono>

using namespace std;

int main() {

    const char* CHIP = "/dev/gpiochip4";
    const unsigned BUTTON = 20;   // Input pin - photoelectric sensor on rail
    const unsigned FLASH = 22;    // Output pin - flash trigger (HIGH during exposure)
    const unsigned time[] = {50000};  // Exposure times in microseconds
    const int time_array_size = sizeof(time) / sizeof(time[0]);

    gpiod::chip chip{CHIP};

    gpiod::line_settings button_behavior;
    button_behavior.set_direction(gpiod::line::direction::INPUT);
    button_behavior.set_bias(gpiod::line::bias::PULL_UP);

    gpiod::line_settings flash_behavior;
    flash_behavior.set_direction(gpiod::line::direction::OUTPUT);
    flash_behavior.set_output_value(gpiod::line::value::INACTIVE); // Start LOW

    auto req = chip.prepare_request()
    .add_line_settings(BUTTON, button_behavior)
    .add_line_settings(FLASH, flash_behavior)
    .do_request();

    bool flashing = false; // Debounce flag to prevent multiple triggers
    int trigger_count = 0; // Total number of triggers fired
    int current_time = 0; // Index into time array

    while(current_time < time_array_size){
        if(req.get_value(BUTTON) == gpiod::line::value::INACTIVE && !flashing){

            flashing = true;

            // Trigger camera and flash simultaneously
            req.set_value(FLASH, gpiod::line::value::ACTIVE);
            std::this_thread::sleep_for(std::chrono::microseconds(time[current_time]));
            req.set_value(FLASH, gpiod::line::value::INACTIVE);    

            flashing = false;
            trigger_count++;

            // After both F and B captures (every 2nd trigger), move to next exposure time
            if(trigger_count % 2 == 0){
                current_time++;
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // delay to avoid rapid retriggering
        }
    }
}

// g++ -o trig trig.cpp -lgpiodcxx -std=c++17
// sudo ./trig
